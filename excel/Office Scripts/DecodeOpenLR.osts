{"version":"0.3.0","body":"// ========================\n// Type Definitions\n// ========================\n\n/**\n * Interface representing the header information extracted from the OpenLR code.\n */\ninterface HeaderInfo {\n  raw: number;\n  locationType: number; // 1 = point, 0 = line\n  extraLRPs: number;    // For line: total LRPs = 2 + extraLRPs\n  offsetPresent: boolean;\n  crcPresent: boolean;\n  numberOfLRPs: number;\n}\n\n/**\n * Interface representing a Location Reference Point (LRP).\n */\ninterface LRP {\n  frc: number;      // Functional Road Class\n  fow: number;      // Form of Way\n  bearing: number;  // Bearing in degrees\n  lat: number;      // Latitude in degrees\n  lon: number;      // Longitude in degrees\n}\n\n/**\n * Interface representing the decoded OpenLR data.\n */\ninterface DecodedOpenLR {\n  header: HeaderInfo;\n  lrps: LRP[];  // For a point location, this array has one element.\n  positiveOffset?: number;\n  negativeOffset?: number;\n  crc?: number;\n}\n\n// ========================\n// BitReader Helper Class\n// ========================\n\n/**\n * A helper class for sequential bit-level reading from a byte array.\n */\nclass BitReader {\n  public byteArray: number[] = [];\n  public bitPos: number = 0;\n\n  constructor(byteArray: number[]) {\n    this.byteArray = byteArray;\n    this.bitPos = 0;\n  }\n\n  /**\n   * Reads the next n bits and returns their numeric value.\n   *\n   * @param n - The number of bits to read.\n   * @returns The numeric value of the read bits.\n   */\n  public readBits(n: number): number {\n    let result: number = 0;\n    for (let i: number = 0; i < n; i++) {\n      const byteIndex: number = Math.floor(this.bitPos / 8);\n      if (byteIndex >= this.byteArray.length) {\n        throw new Error(\"Attempt to read beyond the end of the byte array.\");\n      }\n      const bitIndex: number = 7 - (this.bitPos % 8);\n      const bit: number = (this.byteArray[byteIndex] >> bitIndex) & 1;\n      result = (result << 1) | bit;\n      this.bitPos++;\n    }\n    return result;\n  }\n}\n\n// ========================\n// Helper Functions\n// ========================\n\n/**\n * Converts a Base64 string to a byte array.\n *\n * @param base64 - The Base64-encoded string.\n * @returns An array of byte values (0â€“255).\n */\nfunction base64ToByteArray(base64: string): number[] {\n  const binaryStr: string = atob(base64);\n  const bytes: number[] = [];\n  for (let i: number = 0; i < binaryStr.length; i++) {\n    bytes.push(binaryStr.charCodeAt(i));\n  }\n  return bytes;\n}\n\n/**\n * Reads a signed integer (two's complement) from the next 'bits' bits.\n *\n * @param reader - The BitReader.\n * @param bits - The number of bits to read.\n * @returns The signed integer.\n */\nfunction readSigned(reader: BitReader, bits: number): number {\n  let value: number = reader.readBits(bits);\n  const signBit: number = 1 << (bits - 1);\n  if (value & signBit) {\n    value = value - (1 << bits);\n  }\n  return value;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param degrees - Angle in degrees.\n * @returns Angle in radians.\n */\nfunction degreesToRadians(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n// ========================\n// Generalized OpenLR Decoder\n// ========================\n\n/**\n * Parses the header byte according to the assumed layout.\n *\n * @param headerByte - The 8-bit header.\n * @returns A HeaderInfo object.\n */\nfunction parseHeader(headerByte: number): HeaderInfo {\n  // Bit 7 (MSB): Point Location Indicator (1 = point location, 0 = line location)\n  const pointLocationIndicator: number = (headerByte >> 7) & 0x01;\n  const locationType: number = pointLocationIndicator; // 1=point, 0=line\n\n  // Bits 6-4: Extra LRPs (3 bits)\n  const extraLRPs: number = (headerByte >> 4) & 0x07;\n\n  // Bit 3: Offset flag (1 = offsets present)\n  const offsetPresent: boolean = ((headerByte >> 3) & 0x01) === 1;\n\n  // Bit 2: CRC flag (1 = CRC present)\n  const crcPresent: boolean = ((headerByte >> 2) & 0x01) === 1;\n\n  // Determine the number of LRPs\n  let numberOfLRPs: number;\n  if (locationType === 1) {\n    // Point location: one LRP\n    numberOfLRPs = 1;\n  } else {\n    // Line location: total LRPs = 2 + extraLRPs\n    numberOfLRPs = 2 + extraLRPs;\n  }\n\n  return {\n    raw: headerByte,\n    locationType: locationType,\n    extraLRPs: extraLRPs,\n    offsetPresent: offsetPresent,\n    crcPresent: crcPresent,\n    numberOfLRPs: numberOfLRPs,\n  };\n}\n\n/**\n * Decodes an OpenLR string of any allowed length.\n *\n * @param openlrCode - The Base64-encoded OpenLR string.\n * @returns The decoded OpenLR data.\n */\nfunction decodeGeneralOpenLR(openlrCode: string): DecodedOpenLR {\n  const byteArray: number[] = base64ToByteArray(openlrCode);\n  const reader: BitReader = new BitReader(byteArray);\n\n  // Read header (8 bits)\n  const headerByte: number = reader.readBits(8);\n  const header: HeaderInfo = parseHeader(headerByte);\n\n  // Adjusted handling based on locationType\n  if (header.locationType === 1) {\n    // Point location: one absolute LRP (59 bits)\n    const pointLRP: LRP = decodeAbsoluteLRP(reader);\n    let positiveOffset: number | undefined;\n    let negativeOffset: number | undefined;\n    if (header.offsetPresent) {\n      positiveOffset = reader.readBits(8); // Positive offset (8 bits)\n      negativeOffset = reader.readBits(8); // Negative offset (8 bits)\n    }\n    return {\n      header: header,\n      lrps: [pointLRP],\n      positiveOffset: positiveOffset,\n      negativeOffset: negativeOffset,\n    };\n  } else {\n    // Line location\n    const totalLRPs: number = header.numberOfLRPs; // Equals 2 + extraLRPs\n    let lrps: LRP[] = [];\n    // Decode first LRP (absolute; 59 bits)\n    const firstLRP: LRP = decodeAbsoluteLRP(reader);\n    lrps.push(firstLRP);\n    // Decode intermediate LRPs if any (each 34 bits)\n    for (let i: number = 0; i < totalLRPs - 2; i++) {\n      const intermediateLRP: LRP = decodeRelativeLRP(reader, lrps[lrps.length - 1]);\n      lrps.push(intermediateLRP);\n    }\n    // Decode last LRP (absolute; 59 bits)\n    const lastLRP: LRP = decodeAbsoluteLRP(reader);\n    lrps.push(lastLRP);\n    let positiveOffset: number | undefined;\n    let negativeOffset: number | undefined;\n    if (header.offsetPresent) {\n      positiveOffset = reader.readBits(8); // Positive offset (8 bits)\n      negativeOffset = reader.readBits(8); // Negative offset (8 bits)\n    }\n    return {\n      header: header,\n      lrps: lrps,\n      positiveOffset: positiveOffset,\n      negativeOffset: negativeOffset,\n    };\n  }\n}\n\n/**\n * Decodes an absolute LRP (first, last, or point) from 59 bits.\n *\n * @param reader - The BitReader instance.\n * @returns The decoded LRP with absolute coordinates.\n */\nfunction decodeAbsoluteLRP(reader: BitReader): LRP {\n  const frc: number = reader.readBits(3);\n  const fow: number = reader.readBits(3);\n  const bearingRaw: number = reader.readBits(5);\n  const latRaw: number = reader.readBits(24);\n  const lonRaw: number = reader.readBits(24);\n\n  const bearing: number = bearingRaw * 11.25;\n\n  // Correct scaling factors for latitude and longitude.\n  const lat: number = (latRaw / Math.pow(2, 24)) * 180 - 90;\n  const lon: number = (lonRaw / Math.pow(2, 24)) * 360 - 180;\n\n  return { frc, fow, bearing, lat, lon };\n}\n\n/**\n * Decodes a relative (intermediate) LRP from 34 bits.\n *\n * @param reader - The BitReader.\n * @param previous - The previous LRP (to which the relative difference is applied).\n * @returns The decoded LRP with computed absolute coordinates.\n */\nfunction decodeRelativeLRP(reader: BitReader, previous: LRP): LRP {\n  const frc: number = reader.readBits(3);\n  const fow: number = reader.readBits(3);\n  const bearingRaw: number = reader.readBits(5);\n  const latDiffRaw: number = readSigned(reader, 17);\n  const lonDiffRaw: number = readSigned(reader, 17);\n\n  const bearing: number = bearingRaw * 11.25;\n\n  // Resolutions for latitude and longitude differences.\n  const R_lat: number = 180 / Math.pow(2, 17); // Approximately 0.0013733 degrees per unit.\n  const cosLat: number = Math.cos(degreesToRadians(previous.lat));\n  const R_lon: number = (360 / Math.pow(2, 17)) / cosLat; // Adjusted for latitude.\n\n  const latDiff: number = latDiffRaw * R_lat;\n  const lonDiff: number = lonDiffRaw * R_lon;\n\n  const lat: number = previous.lat + latDiff;\n  const lon: number = previous.lon + lonDiff;\n\n  return { frc, fow, bearing, lat, lon };\n}\n\n// ========================\n// Main Function\n// ========================\n\n/**\n * Main function that reads an OpenLR code from a specified cell,\n * decodes it to extract latitude and longitude values,\n * outputs them to Excel starting from a specified cell,\n * and creates a hyperlink in Excel that opens OpenStreetMap\n * with directions between the first two LRPs.\n *\n * @param workbook - The Excel workbook instance provided by the Office Scripts environment.\n */\nfunction main(workbook: ExcelScript.Workbook): void {\n  const sheet: ExcelScript.Worksheet = workbook.getActiveWorksheet();\n\n  // ========================\n  // Configuration: Specify Input and Output Cells Here\n  // ========================\n  const inputCell: string = \"A3\";    // Cell containing the Base64-encoded OpenLR code.\n  const outputCell: string = \"A11\";  // Cell where the decoded JSON data will be placed.\n  const dataStartCell: string = \"A12\"; // Starting cell for outputting the LRPs.\n\n  // ========================\n  // Read the OpenLR code from the input cell.\n  const openlrCode: string = sheet.getRange(inputCell).getValue() as string;\n\n  // Declare a variable to hold the decoded OpenLR data.\n  let decodedData: DecodedOpenLR;\n\n  try {\n    // Attempt to decode the OpenLR code.\n    decodedData = decodeGeneralOpenLR(openlrCode);\n  } catch (error: unknown) {\n    // If an error occurs during decoding, output the error message to the output cell.\n    if (error instanceof Error) {\n      sheet.getRange(outputCell).setValue(\"Error: \" + error.message);\n    } else {\n      sheet.getRange(outputCell).setValue(\"Error: \" + String(error));\n    }\n    return;\n  }\n\n  // Write the decoded JSON data to the output cell for reference.\n  sheet.getRange(outputCell).setValue(JSON.stringify(decodedData, null, 2));\n\n  // Check if the 'lrps' array exists in the decoded data.\n  if (!decodedData.lrps || decodedData.lrps.length === 0) {\n    sheet.getRange(outputCell).setValue(\"No LRPs found in decoded data\");\n    return;\n  }\n\n  // Write the header for the LRP data starting at the specified cell.\n  sheet.getRange(`${dataStartCell}:C${dataStartCell.slice(1)}`).setValues([[\"lrp\", \"lat\", \"lon\"]]);\n\n  // Extract lat and lon from each LRP and write them to the sheet.\n  const lrps: LRP[] = decodedData.lrps;\n  const startRow: number = parseInt(dataStartCell.slice(1)) + 1; // Data starts from the next row after the header.\n\n  for (let i = 0; i < lrps.length; i++) {\n    const lrp: LRP = lrps[i];\n    const lat: number = lrp.lat;\n    const lon: number = lrp.lon;\n    const row: number = startRow + i;\n    sheet.getRange(`A${row}`).setValue(i + 1); // LRP number.\n    sheet.getRange(`B${row}`).setValue(lat);\n    sheet.getRange(`C${row}`).setValue(lon);\n  }\n\n  // After the data, insert a space (we can leave an empty row).\n  const linkRow: number = startRow + lrps.length + 1;\n\n  // Check if there are at least two LRPs to create the hyperlink.\n  if (lrps.length >= 2) {\n    // Get the first two LRPs' coordinates.\n    const lat1: number = lrps[0].lat;\n    const lon1: number = lrps[0].lon;\n    const lat2: number = lrps[1].lat;\n    const lon2: number = lrps[1].lon;\n    // Calculate the center point between the two coordinates for map centering.\n    const centerLat: number = (lat1 + lat2) / 2;\n    const centerLon: number = (lon1 + lon2) / 2;\n    // Define the zoom level for the map view (0 to 19, where higher is more zoomed in).\n    const zoomLevel: number = 14; // Adjust this value based on the desired map zoom.\n    // Construct the OpenStreetMap Directions URL with the from and to coordinates.\n    const osmUrl: string = `https://www.openstreetmap.org/directions?engine=graphhopper_car&route=${lat1}%2C${lon1}%3B${lat2}%2C${lon2}#map=${zoomLevel}/${centerLat}/${centerLon}`;\n    // Create a hyperlink object to be inserted into the Excel sheet.\n    const hyperlink: ExcelScript.RangeHyperlink = {\n      address: osmUrl, // The URL to open when the hyperlink is clicked.\n      textToDisplay: \"Open OSM Directions\", // The text displayed in the Excel cell.\n      screenTip: \"Click to view directions on OpenStreetMap\", // Tooltip text on hover.\n    };\n    // Target the cell to insert the hyperlink.\n    const targetCell: ExcelScript.Range = sheet.getRange(`A${linkRow}`);\n    // Clear any existing content or hyperlinks in the target cell before inserting the new hyperlink.\n    targetCell.clear();\n    // Set the hyperlink on the target cell.\n    targetCell.setHyperlink(hyperlink);\n    // Set the cell's value to the display text.\n    targetCell.setValue(hyperlink.textToDisplay);\n  } else {\n    // If there are not enough LRPs, write a message.\n    sheet.getRange(`A${linkRow}`).setValue(\"Not enough LRPs to create a hyperlink\");\n  }\n}","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"Main function that reads an OpenLR code from a specified cell,\\ndecodes it to extract latitude and longitude values,\\noutputs them to Excel starting from a specified cell,\\nand creates a hyperlink in Excel that opens OpenStreetMap\\nwith directions between the first two LRPs.\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"- The Excel workbook instance provided by the Office Scripts environment.\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}