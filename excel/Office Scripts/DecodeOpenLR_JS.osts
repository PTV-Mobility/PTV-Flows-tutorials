{"version":"0.3.0","body":"// ========================\n// Type Definitions\n// ========================\n\n/**\n * Interface representing the header information extracted from the OpenLR code.\n */\ninterface HeaderInfo {\n  raw: number;\n  locationType: number; // 1 = point, 0 = line\n  extraLRPs: number;     // For line: total LRPs = 2 + extraLRPs\n  offsetPresent: boolean;\n  crcPresent: boolean;\n  numberOfLRPs: number;\n}\n\n/**\n * Interface representing a Location Reference Point (LRP).\n */\ninterface LRP {\n  frc: number;      // Functional Road Class\n  fow: number;      // Form of Way\n  bearing: number;  // Bearing in degrees\n  lat: number;      // Latitude in degrees\n  lon: number;      // Longitude in degrees\n}\n\n/**\n * Interface representing the decoded OpenLR data.\n */\ninterface DecodedOpenLR {\n  header: HeaderInfo;\n  lrps: LRP[];    // For a point location, this array has one element.\n  positiveOffset?: number;\n  negativeOffset?: number;\n  crc?: number;\n}\n\n// ========================\n// BitReader Helper Class\n// ========================\n\n/**\n * A helper class for sequential bit-level reading from a byte array.\n */\nclass BitReader {\n  public byteArray: number[] = [];\n  public bitPos: number = 0;\n\n  constructor(byteArray: number[]) {\n    this.byteArray = byteArray;\n    this.bitPos = 0;\n  }\n\n  /**\n   * Reads the next n bits and returns their numeric value.\n   *\n   * @param n - The number of bits to read.\n   * @returns The numeric value of the read bits.\n   */\n  public readBits(n: number): number {\n    let result: number = 0;\n    for (let i: number = 0; i < n; i++) {\n      const byteIndex: number = Math.floor(this.bitPos / 8);\n      if (byteIndex >= this.byteArray.length) {\n        throw new Error(\"Attempt to read beyond the end of the byte array.\");\n      }\n      const bitIndex: number = 7 - (this.bitPos % 8);\n      const bit: number = (this.byteArray[byteIndex] >> bitIndex) & 1;\n      result = (result << 1) | bit;\n      this.bitPos++;\n    }\n    return result;\n  }\n}\n\n// ========================\n// Helper Functions\n// ========================\n\n/**\n * Converts a Base64 string to a byte array.\n *\n * @param base64 - The Base64-encoded string.\n * @returns An array of byte values (0â€“255).\n */\nfunction base64ToByteArray(base64: string): number[] {\n  const binaryStr: string = atob(base64);\n  const bytes: number[] = [];\n  for (let i: number = 0; i < binaryStr.length; i++) {\n    bytes.push(binaryStr.charCodeAt(i));\n  }\n  return bytes;\n}\n\n/**\n * Reads a signed integer (two's complement) from the next 'bits' bits.\n *\n * @param reader - The BitReader.\n * @param bits - The number of bits to read.\n * @returns The signed integer.\n */\nfunction readSigned(reader: BitReader, bits: number): number {\n  let value: number = reader.readBits(bits);\n  const signBit: number = 1 << (bits - 1);\n  if (value & signBit) {\n    value = value - (1 << bits);\n  }\n  return value;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param degrees - Angle in degrees.\n * @returns Angle in radians.\n */\nfunction degreesToRadians(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n// ========================\n// Generalized OpenLR Decoder\n// ========================\n\n/**\n * Parses the header byte according to the assumed layout.\n *\n * @param headerByte - The 8-bit header.\n * @returns A HeaderInfo object.\n */\nfunction parseHeader(headerByte: number): HeaderInfo {\n  // Bit 7 (MSB): Point Location Indicator (1 = point location, 0 = line location)\n  const pointLocationIndicator: number = (headerByte >> 7) & 0x01;\n  const locationType: number = pointLocationIndicator; // 1=point, 0=line\n\n  // Bits 6-4: Extra LRPs (3 bits)\n  const extraLRPs: number = (headerByte >> 4) & 0x07;\n\n  // Bit 3: Offset flag (1 = offsets present)\n  const offsetPresent: boolean = ((headerByte >> 3) & 0x01) === 1;\n\n  // Bit 2: CRC flag (1 = CRC present)\n  const crcPresent: boolean = ((headerByte >> 2) & 0x01) === 1;\n\n  // Determine the number of LRPs\n  let numberOfLRPs: number;\n  if (locationType === 1) {\n    // Point location: one LRP\n    numberOfLRPs = 1;\n  } else {\n    // Line location: total LRPs = 2 + extraLRPs\n    numberOfLRPs = 2 + extraLRPs;\n  }\n\n  return {\n    raw: headerByte,\n    locationType: locationType,\n    extraLRPs: extraLRPs,\n    offsetPresent: offsetPresent,\n    crcPresent: crcPresent,\n    numberOfLRPs: numberOfLRPs,\n  };\n}\n\nfunction decodeGeneralOpenLR(openlrCode: string): DecodedOpenLR {\n  try { // Added try-catch block for better error info\n    const byteArray: number[] = base64ToByteArray(openlrCode);\n    const reader: BitReader = new BitReader(byteArray);\n\n    // Read header (8 bits)\n    const headerByte: number = reader.readBits(8);\n    const header: HeaderInfo = parseHeader(headerByte);\n\n    // Adjusted handling based on locationType\n    if (header.locationType === 1) {\n      // Point location: one absolute LRP (59 bits)\n      const pointLRP: LRP = decodeAbsoluteLRP(reader);\n      let positiveOffset: number | undefined;\n      let negativeOffset: number | undefined;\n      if (header.offsetPresent) {\n        positiveOffset = reader.readBits(8); // Positive offset (8 bits)\n        negativeOffset = reader.readBits(8); // Negative offset (8 bits)\n      }\n      return {\n        header: header,\n        lrps: [pointLRP],\n        positiveOffset: positiveOffset,\n        negativeOffset: negativeOffset,\n      };\n    } else {\n      // Line location\n      const totalLRPs: number = header.numberOfLRPs; // Equals 2 + extraLRPs\n      let lrps: LRP[] = [];\n      // Decode first LRP (absolute; 59 bits)\n      const firstLRP: LRP = decodeAbsoluteLRP(reader);\n      lrps.push(firstLRP);\n      // Decode intermediate LRPs if any (each 34 bits)\n      for (let i: number = 0; i < totalLRPs - 2; i++) {\n        try { // Added try-catch inside loop\n          const intermediateLRP: LRP = decodeRelativeLRP(reader, lrps[lrps.length - 1]);\n          lrps.push(intermediateLRP);\n        } catch (innerError) {\n          throw new Error(`Error decoding intermediate LRP ${i + 1}: ${innerError.message}`);\n        }\n      }\n      // Decode last LRP (absolute; 59 bits)\n      try { // Added try-catch for last LRP\n        const lastLRP: LRP = decodeAbsoluteLRP(reader);\n        lrps.push(lastLRP);\n      } catch (lastLrpError) {\n        throw new Error(`Error decoding last LRP: ${lastLrpError.message}`);\n      }\n\n      let positiveOffset: number | undefined;\n      let negativeOffset: number | undefined;\n      if (header.offsetPresent) {\n        positiveOffset = reader.readBits(8); // Positive offset (8 bits)\n        negativeOffset = reader.readBits(8); // Negative offset (8 bits)\n      }\n      return {\n        header: header,\n        lrps: lrps,\n        positiveOffset: positiveOffset,\n        negativeOffset: negativeOffset,\n      };\n    }\n  } catch (topLevelError) { // Catch errors at the top level of decoding\n    throw new Error(`Decoding process error: ${topLevelError.message}`);\n  }\n}\n\n\nfunction decodeAbsoluteLRP(reader: BitReader): LRP {\n  try { // Added try-catch for absolute LRP decoding\n    const frc: number = reader.readBits(3);\n    const fow: number = reader.readBits(3);\n    const bearingRaw: number = reader.readBits(5);\n    const latRaw: number = reader.readBits(24);\n    const lonRaw: number = reader.readBits(24);\n\n    const bearing: number = bearingRaw * 11.25;\n    const lat: number = (latRaw / Math.pow(2, 24)) * 180 - 90;\n    const lon: number = (lonRaw / Math.pow(2, 24)) * 360 - 180;\n\n    return { frc, fow, bearing, lat, lon };\n  } catch (error) {\n    throw new Error(`Error decoding Absolute LRP: ${error.message}`);\n  }\n}\n\n\nfunction decodeRelativeLRP(reader: BitReader, previous: LRP): LRP {\n  try { // Added try-catch for relative LRP decoding\n    const frc: number = reader.readBits(3);\n    const fow: number = reader.readBits(3);\n    const bearingRaw: number = reader.readBits(5);\n    const latDiffRaw: number = readSigned(reader, 17);\n    const lonDiffRaw: number = readSigned(reader, 17);\n\n    const bearing: number = bearingRaw * 11.25;\n\n    // Resolutions for latitude and longitude differences.\n    const R_lat: number = 180 / Math.pow(2, 17);\n    const cosLat: number = Math.cos(degreesToRadians(previous.lat));\n    const R_lon: number = (360 / Math.pow(2, 17)) / cosLat;\n\n    const latDiff: number = latDiffRaw * R_lat;\n    const lonDiff: number = lonDiffRaw * R_lon;\n\n    const lat: number = previous.lat + latDiff;\n    const lon: number = previous.lon + lonDiff;\n\n    return { frc, fow, bearing, lat, lon };\n  } catch (error) {\n    throw new Error(`Error decoding Relative LRP: ${error.message}`);\n  }\n}\n/**\n * Decodes an OpenLR string and outputs an XML representation in the cell.\n * @param openLrBase64String OpenLR string in base64 format\n * @customfunction\n * @description Decodes an OpenLR string and outputs an XML representation in the cell.\n * @param openLrBase64String\n * @returns XML string representation of the decoded OpenLR data.\n */\nfunction DECODEOPENLRTOXML(openLrBase64String: string): string {\n  try {\n    // Attempt to decode the OpenLR string using the provided decoding logic.\n    const decodedData: DecodedOpenLR = decodeGeneralOpenLR(openLrBase64String);\n\n    // Convert the decoded data to XML format.\n    const xmlOutput = convertToXML(decodedData);\n\n    return xmlOutput;\n  } catch (error) {\n    if (error instanceof Error) {\n      return `Error decoding OpenLR: ${error.message}`;\n    } else {\n      return `Error decoding OpenLR: ${String(error)}`;\n    }\n  }\n}\n\n\n/**\n * Converts a JavaScript object to a simple XML string.\n * @param data The JavaScript object to convert.\n * @param rootName The name of the root XML element.\n * @returns An XML string representation of the data.\n */\nfunction convertToXML(decodedData: DecodedOpenLR, rootName: string = \"OpenLRData\"): string {\n  let xmlString = `<${rootName}>\\n`;\n\n  // Header Information\n  xmlString += `  <Header>\\n`;\n  xmlString += `    <Raw>${decodedData.header.raw}</Raw>\\n`;\n  xmlString += `    <LocationType>${decodedData.header.locationType}</LocationType>\\n`;\n  xmlString += `    <ExtraLRPs>${decodedData.header.extraLRPs}</ExtraLRPs>\\n`;\n  xmlString += `    <OffsetPresent>${decodedData.header.offsetPresent}</OffsetPresent>\\n`;\n  xmlString += `    <CrcPresent>${decodedData.header.crcPresent}</CrcPresent>\\n`;\n  xmlString += `    <NumberOfLRPs>${decodedData.header.numberOfLRPs}</NumberOfLRPs>\\n`;\n  xmlString += `  </Header>\\n`;\n\n  // Location Reference Points (LRPs)\n  if (decodedData.lrps && decodedData.lrps.length > 0) {\n    xmlString += `  <LocationReferencePoints>\\n`;\n    decodedData.lrps.forEach((lrp, index) => {\n      xmlString += `    <LRP index=\"${index + 1}\">\\n`;\n      xmlString += `      <FRC>${lrp.frc}</FRC>\\n`;\n      xmlString += `      <FOW>${lrp.fow}</FOW>\\n`;\n      xmlString += `      <Bearing>${lrp.bearing}</Bearing>\\n`;\n      xmlString += `      <Latitude>${lrp.lat}</Latitude>\\n`;\n      xmlString += `      <Longitude>${lrp.lon}</Longitude>\\n`;\n      xmlString += `    </LRP>\\n`;\n    });\n    xmlString += `  </LocationReferencePoints>\\n`;\n  }\n\n  // Offsets (if present)\n  if (decodedData.header.offsetPresent) {\n    xmlString += `  <Offsets>\\n`;\n    if (decodedData.positiveOffset !== undefined) {\n      xmlString += `    <PositiveOffset>${decodedData.positiveOffset}</PositiveOffset>\\n`;\n    }\n    if (decodedData.negativeOffset !== undefined) {\n      xmlString += `    <NegativeOffset>${decodedData.negativeOffset}</NegativeOffset>\\n`;\n    }\n    xmlString += `  </Offsets>\\n`;\n  }\n\n  // CRC (if present)\n  if (decodedData.header.crcPresent && decodedData.crc !== undefined) {\n    xmlString += `  <CRC>${decodedData.crc}</CRC>\\n`;\n  }\n\n  xmlString += `</${rootName}>`;\n  return xmlString;\n}\n\n// ========================\n// Main Function - for running directly as Office Script\n// ========================\n\n/**\n * Main function that reads an OpenLR code from a specified cell,\n * decodes it to extract latitude and longitude values,\n * outputs them to Excel starting from a specified cell,\n * and creates a hyperlink in Excel that opens OpenStreetMap\n * with directions between the first two LRPs.\n *\n * @param workbook - The Excel workbook instance provided by the Office Scripts environment.\n */\nfunction main(workbook: ExcelScript.Workbook): void {\n  const sheet: ExcelScript.Worksheet = workbook.getActiveWorksheet();\n\n  // ========================\n  // Configuration: Specify Input and Output Cells Here\n  // ========================\n  const inputCell: string = \"c6\";     // Cell containing the Base64-encoded OpenLR code.\n  const outputCell: string = \"h6\";    // Cell where the decoded JSON data will be placed.\n  const dataStartCell: string = \"i6\"; // Starting cell for outputting the LRPs.\n\n  // ========================\n  // Read the OpenLR code from the input cell.\n  const openlrCode: string = sheet.getRange(inputCell).getValue() as string;\n\n  // Declare a variable to hold the decoded OpenLR data.\n  let decodedData: DecodedOpenLR;\n\n  try {\n    // Attempt to decode the OpenLR code.\n    decodedData = decodeGeneralOpenLR(openlrCode);\n  } catch (error: unknown) {\n    // If an error occurs during decoding, output the error message to the output cell.\n    if (error instanceof Error) {\n      sheet.getRange(outputCell).setValue(\"Error: \" + error.message);\n    } else {\n      sheet.getRange(outputCell).setValue(\"Error: \" + String(error));\n    }\n    return;\n  }\n\n  // Write the decoded JSON data to the output cell for reference.\n  sheet.getRange(outputCell).setValue(convertToXML(decodedData)); // Output XML in cell A11\n\n  // Check if the 'lrps' array exists in the decoded data.\n  if (!decodedData.lrps || decodedData.lrps.length === 0) {\n    sheet.getRange(outputCell).setValue(\"No LRPs found in decoded data\");\n    return;\n  }\n\n  // Write the header for the LRP data starting at the specified cell.\n  sheet.getRange(`${dataStartCell}:C${dataStartCell.slice(1)}`).setValues([[\"lrp\", \"lat\", \"lon\"]]);\n\n  // Extract lat and lon from each LRP and write them to the sheet.\n  const lrps: LRP[] = decodedData.lrps;\n  const startRow: number = parseInt(dataStartCell.slice(1)) + 1; // Data starts from the next row after the header.\n\n  for (let i = 0; i < lrps.length; i++) {\n    const lrp: LRP = lrps[i];\n    const lat: number = lrp.lat;\n    const lon: number = lrp.lon;\n    const row: number = startRow + i;\n    sheet.getRange(`A${row}`).setValue(i + 1); // LRP number.\n    sheet.getRange(`B${row}`).setValue(lat);\n    sheet.getRange(`C${row}`).setValue(lon);\n  }\n\n  // After the data, insert a space (we can leave an empty row).\n  const linkRow: number = startRow + lrps.length + 1;\n\n  // Check if there are at least two LRPs to create the hyperlink.\n  if (lrps.length >= 2) {\n    // Get the first two LRPs' coordinates.\n    const lat1: number = lrps[0].lat;\n    const lon1: number = lrps[0].lon;\n    const lat2: number = lrps[1].lat;\n    const lon2: number = lrps[1].lon;\n    // Calculate the center point between the two coordinates for map centering.\n    const centerLat: number = (lat1 + lat2) / 2;\n    const centerLon: number = (lon1 + lon2) / 2;\n    // Define the zoom level for the map view (0 to 19, where higher is more zoomed in).\n    const zoomLevel: number = 14; // Adjust this value based on the desired map zoom.\n    // Construct the OpenStreetMap Directions URL with the from and to coordinates.\n    const osmUrl: string = `https://www.openstreetmap.org/directions?engine=graphhopper_car&route=${lat1}%2C${lon1}%3B${lat2}%2C${lon2}#map=${zoomLevel}/${centerLat}/${centerLon}`;\n    // Create a hyperlink object to be inserted into the Excel sheet.\n    const hyperlink: ExcelScript.RangeHyperlink = {\n      address: osmUrl, // The URL to open when the hyperlink is clicked.\n      textToDisplay: \"Open OSM Directions\", // The text displayed in the Excel cell.\n      screenTip: \"Click to view directions on OpenStreetMap\", // Tooltip text on hover.\n    };\n    // Target the cell to insert the hyperlink.\n    const targetCell: ExcelScript.Range = sheet.getRange(`A${linkRow}`);\n    // Clear any existing content or hyperlinks in the target cell before inserting the new hyperlink.\n    targetCell.clear();\n    // Set the hyperlink on the target cell.\n    targetCell.setHyperlink(hyperlink);\n    // Set the cell's value to the display text.\n    targetCell.setValue(hyperlink.textToDisplay);\n  } else {\n    // If there are not enough LRPs, write a message.\n    sheet.getRange(`A${linkRow}`).setValue(\"Not enough LRPs to create a hyperlink\");\n  }\n}","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"Main function that reads an OpenLR code from a specified cell,\\ndecodes it to extract latitude and longitude values,\\noutputs them to Excel starting from a specified cell,\\nand creates a hyperlink in Excel that opens OpenStreetMap\\nwith directions between the first two LRPs.\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"- The Excel workbook instance provided by the Office Scripts environment.\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}